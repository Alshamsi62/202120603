# -*- coding: utf-8 -*-
"""Assignment 1 Chocolates sorting.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Q9fUDkAik3lk8VHNgrtEfIjdxtAye2-H
"""

# Redefining the functions after the state has been reset.

def distribute_chocolates_iterative(chocolates, students):
    # Ensure there are enough chocolates for each student
    if len(chocolates) < len(students):
        return "Not enough chocolates for each student."

    # Initialize a dictionary to keep track of distributed chocolates
    distributed_chocolates = {}

    # Iterate through students and distribute chocolates
    for i, student in enumerate(students):
        distributed_chocolates[student] = chocolates[i]

    return distributed_chocolates

def distribute_chocolates_recursive(chocolates, students, index=0, distributed_chocolates=None):
    # Use a non-mutable object as default argument
    if distributed_chocolates is None:
        distributed_chocolates = {}

    # Base case: all students have received chocolates
    if index == len(students) or index == len(chocolates):
        return distributed_chocolates

    # Recursive case: distribute chocolate to the current student
    distributed_chocolates[students[index]] = chocolates[index]

    # Recur to the next student
    return distribute_chocolates_recursive(chocolates, students, index + 1, distributed_chocolates)

# Test Cases
chocolates_test = [
    {"weight": 56, "price": 5, "type": "milk"},
    {"weight": 70, "price": 2, "type": "white"},
    {"weight": 50, "price": 4, "type": "dark"},
    {"weight": 50, "price": 4, "type": "dark"},
]

students_test = ["Rashed", "Mohammed", "Khalifa"]

# Test the iterative distribution
result_iterative = distribute_chocolates_iterative(chocolates_test, students_test)
print("Iterative Distribution Result:", result_iterative)

# Test the recursive distribution
result_recursive = distribute_chocolates_recursive(chocolates_test, students_test)
print("Recursive Distribution Result:", result_recursive)



# Complete code for sorting chocolates by weight and then by price

def merge_sort(arr, key):
    if len(arr) > 1:
        mid = len(arr) // 2
        L = arr[:mid]
        R = arr[mid:]

        merge_sort(L, key)
        merge_sort(R, key)

        i = j = k = 0

        while i < len(L) and j < len(R):
            if L[i][key] < R[j][key]:
                arr[k] = L[i]
                i += 1
            else:
                arr[k] = R[j]
                j += 1
            k += 1

        while i < len(L):
            arr[k] = L[i]
            i += 1
            k += 1

        while j < len(R):
            arr[k] = R[j]
            j += 1
            k += 1

def sort_chocolates_by_weight(chocolates):
    merge_sort(chocolates, 'weight')

def sort_chocolates_by_price(chocolates):
    merge_sort(chocolates, 'price')

# Define chocolates list
chocolates_list = [
    {'weight': 50, 'price': 2, 'type': 'Dark'},
    {'weight': 45, 'price': 1.5, 'type': 'Milk'},
    {'weight': 55, 'price': 2.5, 'type': 'White'},
    {'weight': 40, 'price': 2, 'type': 'Dark'}
]

# Sort chocolates by weight
sort_chocolates_by_weight(chocolates_list)
print("Chocolates sorted by weight:", chocolates_list)

# Sort chocolates by price
sort_chocolates_by_price(chocolates_list)
print("Chocolates sorted by price:", chocolates_list)

# Let's use the provided binary_search_chocolate function to find a specific chocolate by weight and price,
# and then we will print the results.

def binary_search_chocolate(chocolates, target, key):
    low, high = 0, len(chocolates) - 1

    while low <= high:
        mid = (low + high) // 2
        if chocolates[mid][1][key] == target:
            return chocolates[mid][0]  # Return the student's identifier
        elif chocolates[mid][1][key] < target:
            low = mid + 1
        else:
            high = mid - 1

    return None

# Assuming chocolates are sorted by weight or price as needed for each test case
chocolates_assigned = [
    ("Rashed", {"weight": 40, "price": 1, "type": "Milk"}),
    ("Abdulla", {"weight": 45, "price": 1.5, "type": "Dark"}),
    ("Khalifa", {"weight": 50, "price": 2, "type": "White"}),
    ("Mohammed", {"weight": 55, "price": 2.5, "type": "Bitter"})
]

# Sort the list of chocolates by weight for binary search
chocolates_assigned.sort(key=lambda x: x[1]['weight'])
# Let's try to find a chocolate with a specific weight
student_with_chocolate_by_weight = binary_search_chocolate(chocolates_assigned, 50, 'weight')
print(f"Student with chocolate weighing 50: {student_with_chocolate_by_weight}")

# Sort the list of chocolates by price for binary search
chocolates_assigned.sort(key=lambda x: x[1]['price'])
# Let's try to find a chocolate with a specific price
student_with_chocolate_by_price = binary_search_chocolate(chocolates_assigned, 1.5, 'price')
print(f"Student with chocolate priced at 1.5: {student_with_chocolate_by_price}")